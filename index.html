<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Maze Maker</title>
    <link href='https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Material+Icons' rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">-->
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
        }
    </style>

</head>

<body>
    <div id='app'>
        <v-app>
            <v-content>
                <v-container>
                    <v-row>
                        <v-col class="text-center display-1">
                            Welcome to the Maze Maker
                        </v-col>
                    </v-row>
                    <v-row>
                        <v-col>
                            <v-card>
                                <v-card-title>
                                    <v-slider validate-on-blur=true thumb-label="always" min="10" max="100" class="ma-1" label="Columns" v-model="mazeCols" @end="rebuild()" :rules="[rules.isInt]">
                                    </v-slider>
                                    <v-slider thumb-label="always" min="10" max="100" class="ma-1" label="Rows" v-model="mazeRows" @end="rebuild()" :rules="[rules.isInt]">
                                    </v-slider>
                                    <v-slider thumb-label="always" min="5" max="50" class=" ma-1" label="Pixels" v-model="mazePixels" @input="resize()" :rules="[rules.isInt]">
                                    </v-slider>

                                </v-card-title>
                            </v-card>
                        </v-col>
                    </v-row>
                    <v-row>
                        <v-col>
                            <canvas id="canv"></canvas>
                            <div>
                                <img src="L.png" id="slt">
                            </div>
                            <div>
                                <canvas id="imageCanvas"></canvas>
                            </div>
                        </v-col>
                    </v-row>
                </v-container>
            </v-content>
        </v-app>

    </div>



    <script src='https://code.jquery.com/jquery-3.2.1.min.js'></script>
    <script src='https://unpkg.com/vue'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>


    <script>
        var app = new Vue({
            el: '#app',
            vuetify: new Vuetify(),
            data: {
                mazeRows: 50,
                mazeCols: 50,
                mazePixels: 10,
                nodes: [],
                pixels: [],
                pixelWidth: 0,
                pixelHeigh: 0,
                can: {},
                canWidth: 200,
                canHeight: 200,
                margin: 50,
                rules: {
                    isInt: value => !isNaN(value) && Math.floor(parseInt(value)) == Math.floor(+value),
                }
            },
            mounted() {
                this.can = document.getElementById("canv");

                let slt = document.getElementById("slt");
                let imageCanvas = document.getElementById("imageCanvas");
                imageCanvas.width = slt.width;
                imageCanvas.height = slt.height;
                let imgCtx = imageCanvas.getContext("2d");
                imgCtx.drawImage(slt, 0, 0);
                var imgData = imgCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);

                //From https://www.w3schools.com/tags/canvas_getimagedata.asp
                var i = 0;
                //this.pixels = new Array(imageCanvas.width);
                //this.pixels.forEach(i => i.push(new Array(imageCanvas.height)));
                this.pixels = Array.from(Array(imageCanvas.width), () => new Array(imageCanvas.height));

                this.pixelWidth = imageCanvas.width;
                this.pixelHeight = imageCanvas.height;
                for (let y = 0; y < imageCanvas.height; y++) {
                    for (let x = 0; x < imageCanvas.width; x++) {
                        let r, g, b;
                        r = imgData.data[i];
                        b = imgData.data[i + 1]
                        g = imgData.data[i + 2];
                        this.pixels[x][y] = (r + g + b) / 3 > 10 ? true : false;
                        //this.pixels[x][y] = true;
                        i += 4;
                    }
                }



                this.buildMaze();
                this.resize();
                this.draw();

            },
            methods: {
                resize() {
                    if (!this.rules.isInt(this.mazePixels))
                        return;
                    if (!this.mazePixels)
                        return;

                    this.margin = parseInt(this.mazePixels)
                    this.mazePixels = parseInt(this.mazePixels);
                    this.canWidth = this.mazeCols * this.mazePixels + (this.margin * 2);
                    this.canHeight = this.mazeRows * this.mazePixels + (this.margin * 2);
                    //Calculate the width and height of the canvas

                    this.draw();
                },
                rebuild() {
                    this.buildMaze();
                    this.mazePixels = +this.mazePixels;
                    this.canWidth = +this.canWidth;
                    this.canHeight = +this.canHeight;
                    this.resize();
                    this.draw();
                },
                buildMaze() {
                    this.nodes = [];
                    if (!this.rules.isInt(this.mazeCols) || !this.rules.isInt(this.mazeRows))
                        return;

                    if (!this.mazeCols || !this.mazeRows) return

                    this.mazeCols = +this.mazeCols;
                    this.mazeRows = +this.mazeRows;
                    let countVisibleNodes = 0;
                    for (let x = 0; x < this.mazeCols; x++) {
                        this.nodes.push([])
                        for (let y = 0; y < this.mazeRows; y++) {
                            let node = {
                                up: false,
                                down: false,
                                left: false,
                                right: false,
                                x: x,
                                y: y,
                                visible: true,
                            }

                            pX = Math.floor(x / this.mazeCols * this.pixelWidth)
                            pY = Math.floor(y / this.mazeRows * this.pixelHeight)
                            if (this.pixels[pX][pY] == false)
                                node.visible = false;

                            if (node.visible)
                                countVisibleNodes++;
                            this.nodes[x].push(node);
                        }
                    }
                    //1. Pick a starting node. Add it to a list of 'in' nodes
                    //2. Pick a random node next to a node in the 'in'   nodes
                    //3. Connect that node
                    //4. Repeat 2 and 3 until all nodes are in the spanning tree //1.
                    let inNodes = []
                    let xFirst, yFirst;
                    do {
                        xFirst = Math.floor(Math.random() * this.mazeCols);
                        yFirst = Math.floor(Math.random() * this.mazeRows);
                    } while (this.nodes[xFirst][yFirst].visible == false)
                    let firstNode = this.nodes[xFirst][yFirst];
                    inNodes.push(firstNode);
                    //4.
                    while (inNodes.length < countVisibleNodes) {
                        //2.
                        let valid = false;
                        while (!valid) {
                            valid = true;
                            let randomIndex = Math.floor(Math.random() * inNodes.length);
                            let randomNode = inNodes[randomIndex];
                            let randomX = 0
                            let randomY = 0
                            let randomR = Math.random();
                            if (randomR < .25)
                                randomX = -1;
                            else if (randomR < .5) randomX = 1;
                            else if (randomR < .75) randomY = -1;
                            else randomY = 1;
                            let possibleX = randomNode.x + randomX;
                            let possibleY = randomNode.y + randomY;
                            if (possibleX < 0 || possibleX >= this.mazeCols ||
                                possibleY < 0 || possibleY >= this.mazeRows)
                                continue;
                            if (this.nodes[possibleX][possibleY].visible == false)
                                continue;
                            let nextNode = this.nodes[possibleX][possibleY];
                            if (inNodes.includes(nextNode))
                                continue;

                            valid = true
                            inNodes.push(nextNode);
                            if (randomX == -1) {
                                randomNode.left = true;
                                nextNode.right = true;
                            } else if (randomX == 1) {
                                randomNode.right = true;
                                nextNode.left = true;
                            } else if (randomY == 1) {
                                randomNode.down = true;
                                nextNode.up = true;
                            } else if (randomY == -1) {
                                randomNode.up = true;
                                nextNode.down = true;
                            }


                        }
                    }

                    //Now open up the start and end
                    this.nodes[0][0].left = true;
                    this.nodes[this.mazeCols - 1][this.mazeRows - 1].right = true;
                },
                draw() {
                    this.can.width = this.canWidth;
                    this.can.height = this.canHeight;
                    this.can.style.width = this.canWidth + "px";
                    this.can.style.height = this.canHeight + "px";

                    ctx = this.can.getContext("2d");
                    ctx.fillStyle = "white"
                    ctx.fillRect(0, 0, this.can.width, this.can.height);

                    ctx.translate(this.margin, this.margin);

                    for (let x = 0; x < this.mazeCols; x++) {
                        let line = this.nodes[x]
                        for (let y = 0; y < this.mazeRows; y++) {
                            let node = line[y];
                            if (node.visible == false)
                                continue;
                            ctx.fillStyle = "black";
                            let centerX = x * this.mazePixels;
                            let centerY = y * this.mazePixels;
                            if (!node.up) {
                                ctx.strokeStyle = "black"
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(centerX, centerY);
                                ctx.lineTo(centerX + this.mazePixels, centerY);
                                ctx.stroke();
                            }
                            if (!node.down) {
                                ctx.strokeStyle = "black"
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(centerX, centerY + this.mazePixels);
                                ctx.lineTo(centerX + this.mazePixels, centerY + this.mazePixels);
                                ctx.stroke();
                            }
                            if (!node.left) {
                                ctx.strokeStyle = "black"
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(centerX, centerY);
                                ctx.lineTo(centerX, centerY + this.mazePixels);
                                ctx.stroke();
                            }
                            if (!node.right) {
                                ctx.strokeStyle = "black"
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(centerX + this.mazePixels, centerY);
                                ctx.lineTo(centerX + this.mazePixels, centerY + this.mazePixels);
                                ctx.stroke();
                            }
                        }
                    }
                }

            },
        });
    </script>

</body>

</html>
